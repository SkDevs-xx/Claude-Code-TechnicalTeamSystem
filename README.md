# Claude Code tmux Max: マルチエージェント開発フレームワーク

このリポジトリは、tmux環境内でシミュレートされた、マルチエージェントAIによる開発を行うための先進的なフレームワークです。このプロジェクトの最終目標は、AIエージェントに対して明確な階層構造と厳格な通信プロトコルを確立することにより、安定的で、予測可能かつ堅牢なソフトウェア開発を実現することにあります。

## このプロジェクトの背景

このフレームワークは、一人の人間のアーキテクトと大規模言語モデルとの間の、集中的かつ反復的な対話を通じて設計・構築されました。これは、単一の巨大なAI（モノリス）が持つ本質的な予測不能性を、AIを協調的な専門家チームへと組織化することによって克服するという、高度なAIマネジメント理論の実践的な実装です。

## 設計思想：一枚岩（モノリス）から組織へ

単一で強力なAIに複雑なタスクを与えると、時に「ハルシネーション（幻覚）」を起こしたり、予測不能なショートカットをとったりすることがあります。このフレームワークは、AIを人間の開発チームのように階層的な組織へと構造化することで、これらのリスクを軽減できるという哲学に基づいています。

限定的かつ明確な役割と責任を割り当てることで、私たちは一人の「全知な」AIを、予測可能な専門家チームへと変貌させます。

-   **PRESIDENT (監督者):** 高レベルなビジョンを描く存在。目標を設定するが、決してコードには触れない。
-   **BOSS (管理者):** プロジェクトマネージャー。タスクを分解し、ワーカーを管理し、品質保証に全責任を負う。
-   **WORKER (実行者):** 専門の開発者。全体像を気にすることなく、割り当てられた特定のタスクの実行にのみ集中する。

この構造は、最上位のエージェント（PRESIDENT）が実装の詳細で迷子になることを防ぎ、すべてのコードが品質担当のエージェント（BOSS）によって検証されることを保証します。

## 主な特徴

-   **階層的なエージェント構造:** 明確な指揮系統（PRESIDENT → BOSS → WORKER）が、予測可能なワークフローを保証します。
-   **モジュール化された厳格な役割定義:** エージェントの役割、責任、禁止事項を中央の`roles.json`ファイルで厳格に定義し、AIにとっての「信頼できる唯一の情報源」を提供します。
-   **高度なAI制御プロトコル:**
    -   **第一指示プロトコル:** AIが日本語の指示をまず内部で英語に翻訳し、技術要件を深く、曖昧さなく理解することを強制する必須プロセス。
    -   **バイリンガル通信ポリシー:** 指示書は論理的な明確性のために英語で記述し、エージェント間のすべての通信はユーザーの利便性のために日本語で実行します。
-   **tmuxによるマルチエージェント・シミュレーション:** `tmux`の能力を最大限に活用し、各ペインが一人の独立したAIエージェントとして機能する仮想環境を構築します。
-   **堅牢なエラー処理サイクル:** `BOSS`エージェントが品質保証サイクル（統合、ビルド、テスト）の全責任を負い、失敗時には`WORKER`に対して的確な修正指示を発行します。

## アーキテクチャとファイル構成

フレームワークの構成はモジュール化されており、メンテナンスと理解を容易にします。

```
.
├── CLAUDE.md               # システム全体の憲法となるマスターファイル
├── roles.json              # エージェントの役割を定義する「信頼できる唯一の情報源」(JSON形式)
├── roles/
│   ├── president.md        # PRESIDENT用の役割別指示書
│   ├── boss.md             # BOSS用の役割別指示書
│   └── worker.md           # WORKER用の役割別指示書
└── agent-send.sh           # 特定のtmuxペインにメッセージを送信するためのユーティリティスクリプト
```

## はじめに

### 前提条件

-   **tmux:** `tmux`がインストールされている必要があります。
-   **Claude Code:** このフレームワークは、ターミナルと対話できるClaude Codeのような環境で使用されることを想定しています。
-   **シェル環境:** 標準的なUnixライクシェル（bash, zshなど）。

### セットアップ

1.  **リポジトリをクローン:**
    ```bash
    git clone https://github.com/SkDevs-xx/Claude-Code-tmux-Max.git
    cd Claude-Code-tmux-Max
    ```

2.  **スクリプトに実行権限を付与:**
    ```bash
    chmod +x agent-send.sh
    ```
    *(注意: `agent-send.sh`は、あなたのtmuxペインの名前やインデックスに合わせて、正しくターゲットを指定できるように設定する必要があります。)*

3.  **tmuxセッションの起動:**
    各エージェント用のペインを持つtmuxセッションを作成します。例：
    -   `PRESIDENT` (ペイン 0)
    -   `BOSS` (ペイン 1)
    -   `WORKER1` (ペイン 2)
    -   `WORKER2` (ペイン 3)
    -   `WORKER3` (ペイン 4)

## ワークフロー：使い方

このフレームワークは、人間が最初のトリガーを引くことを必要とします。

1.  **役割の初期化 (任意だが推奨):**
    このシステムはコマンドごとに役割を再注入するように設計されていますが、各エージェントに対応する`.md`ファイルからセットアッププロンプトを送信することで、エージェントを初期化（プライミング）できます。

2.  **プロジェクトのキックオフ (人間の操作):**
    自動化された全ワークフローは、人間のユーザーが`PRESIDENT`のペインに**たった一つのコマンド**を送信することで開始されます。これがプロジェクトを開始するために必要な唯一の手動ステップです。
    ```bash
    # PRESIDENTのペインにこのコマンドを送信する
    あなたはpresidentです。
    ```

3.  **自動化されたカスケード（連鎖反応）:**
    -   トリガーを受け取ると、**PRESIDENT**は自身の主要な機能を自動的に実行します：**BOSS**に対して詳細なプロジェクト指示を送信します。
    -   **BOSS**はその指示を受け取り、より小さなタスクに分解し、**WORKER1, WORKER2, WORKER3**に割り当てます。
    -   各**WORKER**はタスクを実行し、完了を**BOSS**に報告します。
    -   すべての**WORKER**から報告が上がると、**BOSS**は品質保証サイクルを実行します。問題が発見された場合、修正指示を発行します。
    -   品質保証を無事に通過した後、**BOSS**は最終的な統合レポートを**PRESIDENT**に送信します。

4.  **完了:**
    `PRESIDENT`が`BOSS`から最終的な成功報告を受け取った時点で、ワークフローは完了します。
